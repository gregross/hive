// SSAdll.cpp : Defines the entry point for the console application.

#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <string>
#include <strstream>
#include <stdio.h>
#include <math.h>
#include "fortran.h"
#include "ssalib.h"
#include "atb_alg_SSA.h"

using namespace std;

// local macro definitions

#define JACCARD  501
#define QINDEX   502
#define YULESQ   503
#define EUCLID   504
#define DICHOT   505
#define YES      100
#define NO       0
#define CSV 1
#define FORTRAN 2
#define UNKNOWN 3
#define FAILURE 4
#define PREDEFINE 510
#define NO_PREDEFINE 520
#define SCREEN_ADJUST 240
#define RUN 0
#define RECALCULATE 1
#define LABELLENGTH 10
#define DELTAX -10
#define DELTAY  10
#define YINC 2;
#define XINC 2;

// Data structure for holding SSA parameters.

	typedef struct 
	{
		char filename[255];
		char outfile[12];
		char title[80];
		int numvars;
		int mind;
		int maxd;
		char sim_dissim;
		char plots_dist;
		char min_alien;
		char predef_inp;
		int matrix_shape;
		char metric;
		char local_mono;
		char fnote[80];
		char dichot;
		int coef;                // These two are
		char missing_data;       // mutually exclusive
	} ssa_parameters;

class SSA
{
	public:

		SSA()
		{
			data = 0;

			selection_vector = new int[100];
			deselect(selection_vector, RESET);
			SetSsaDefaults();
			FILE* fp = fopen("COEFFS.TMP", "w");
			fclose(fp);
		}

		void run(char *fle)
		{
			strcpy(filename, fle);
			if (data) delete_data(params.numvars);
			int user_choice_config = NO_PREDEFINE;

			fileformat fmt = inquire_file_format(filename);

			params.numvars = fmt.ncols;

			// create a FORTRAN format statement

			char format[80];
			sprintf(format, "(%dF8.3)", fmt.ncols);

			// check if data are dichotomous

			if (fmt.isdichot || fmt.isbinary) 
				params.dichot = 'y';
			else 
				params.dichot = 'n';

			if (fmt.shape == 2) 
			{
				params.matrix_shape = 1;
				params.numvars++;
			}
			else // for rectangular data sets
				params.matrix_shape = 2;

			strcpy(params.fnote, format);

			// remove temporary files

			FILE* fp;
			if (fp = fopen("COORDS.TMP", "r"))
			{
				fclose(fp);
				int rval = remove("COORDS.TMP");
				if (rval == -1)
				{
					return;
				}
			}

			if (fp = fopen("COEFFS.TMP", "r"))
			{
				fclose(fp);
				int rval = remove("COEFFS.TMP");
				if (rval == -1)
				{
					return;
				}
			}

			if (fp = fopen("fndata.tmp", "r"))
			{
				fclose(fp);
				int rval = remove("fndata.tmp");
				if (rval == -1)
				{
					return;
				}
			}

			if (user_choice_config != PREDEFINE)
			{
				params.predef_inp = 'n';

				write_subs_fortran(filename, "fndata.tmp", fmt, 8, 3, selection_vector);
			}

			// Write the current parameter to the temporary instruction file.
			
			WriteSsaInsfile();

			try
			{
				MAIN__();
			}
			catch (...)
			{
				delFiles();
				printf("There was an error in the native SSA routine. \n");
			}
		}

		~SSA()
		{
			if (data) delete_data(params.numvars);
			delete [] selection_vector;
			//cleanup();
		}

		/*void run(char *fle);*/

	protected:
		ssa_parameters params;
		char filename[255];
		fileformat fmt;
		int* selection_vector;
		double** data;

		void SetSsaDefaults()
		{
			strcpy(params.outfile, "OUT.TXT");
			strcpy(params.title, "Generated by L.I.F.A");
			strcpy(params.filename, "fndata.tmp");
			params.mind = 2;
			params.maxd = 2;
			params.sim_dissim = 2;
			params.plots_dist = 'y';
			params.min_alien = 'y';
			params.predef_inp = 'n';
			params.matrix_shape = 2;
			params.metric = 'n';
			params.local_mono = 'y';
			params.dichot = 'y';
			params.coef = 1;
			params.missing_data = 'n';
		}

		void cleanup()
		{
			// remove temporary files

			FILE* fp;
			if (fp = fopen("COORDS.TMP", "r"))
			{
				fclose(fp);
				int rval = remove("COORDS.TMP");
				if (rval == -1)
				{
				return;
				}
			}
			   
			if (fp = fopen("export.tmp", "r"))
			{
				fclose(fp);
				int rval = remove("export.tmp");
				if (rval == -1)
				{
				return;
				}
			}
			if (fp = fopen("export.nam", "r"))
			{
				fclose(fp);
				int rval = remove("export.tmp");
				if (rval == -1)
				{
				return;
				}
			}
			   
			if (fp = fopen("COEFFS.TMP", "r"))
			{
				fclose(fp);
				int rval = remove("COEFFS.TMP");
				if (rval == -1)
				{
				return;
				}
			}
			  
			if (fp = fopen("fndata.tmp", "r"))
			{
				fclose(fp);
				int rval = remove("fndata.tmp");
				if (rval == -1)
				{
				return;
				}
			}
		}

		void delete_data(int record_count)
		{
			// Delete memory allocation

			for(int i = 0; i < record_count; i++)
			{
				delete [] data[i];
			}
			delete [] data;

			data = 0;
		}

		void WriteSsaInsfile()
		{
			// inst.tmp is the constant instruction file name.

			FILE* fp;
			fp = fopen("inst.tmp", "w");
			if (!fp)
			{
				return;
			}
			fprintf(fp, "%s\n", params.filename);
			fprintf(fp, "%s\n", params.outfile);
			fprintf(fp, "%s\n", params.title);
			fprintf(fp, "%d\n", params.numvars);
			fprintf(fp, "%d\n", params.mind);
			fprintf(fp, "%d\n", params.maxd);
			fprintf(fp, "%d\n", params.sim_dissim);
			fprintf(fp, "%c\n", params.plots_dist);
			fprintf(fp, "%c\n", params.min_alien);
			fprintf(fp, "%c\n", params.predef_inp);

			// for predefined configuration, there is an extra parameter
			// if (params.predef_inp == 'y') fprintf(fp, "n\n" );

			fprintf(fp, "%d\n", params.matrix_shape);
			if (params.matrix_shape == 1) 
				fprintf(fp, "n\n"); // no missing cells

			fprintf(fp, "%c\n", params.metric);
			fprintf(fp, "%c\n", params.local_mono);
			fprintf(fp, "%s\n", params.fnote);
			fprintf(fp, "%c\n", params.dichot);

			if (params.dichot == 'y' && params.sim_dissim != 1 )
				fprintf(fp, "%d\n", params.coef);
			else
				fprintf(fp, "%c\n", params.missing_data);

			fclose(fp);

			fp = fopen("PREDEF.TMP", "w");
			fclose(fp);
		}
};

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

JNIEXPORT void JNICALL Java_atb_alg_SSA_doSSA(JNIEnv * env, jclass obj, jstring sFileName)
{
	{
		SSA ssa;

		// Convert from jstring to c string:

		const char *str = (*env).GetStringUTFChars(sFileName, 0);

		char fn[255];
		strcpy(fn, str);

		ssa.run(fn);

		(*env).ReleaseStringUTFChars(sFileName, str);
	}
}