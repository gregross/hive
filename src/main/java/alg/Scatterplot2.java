/**
 * Algorithmic testbed
 *
 * Scatterplot
 *
 * Class represents an instance of a visual module for a scatterplot visualisation
 *
 *  @author Greg Ross, Alistair Morrison
 */
package alg; 
import math.*;

import parent_gui.dataVolumeThresholding.HybridGenerator;
import parent_gui.dataVolumeThresholding.HybridAdaptor;
import alg.scatterplot2.*;
import parent_gui.*;
import data.*;

import java.util.*;
import java.awt.Color;
import javax.swing.Box.Filler;
import java.awt.Dimension;

import javax.swing.JSlider;
import javax.swing.border.TitledBorder;
import javax.swing.event.*;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JLabel;

public class Scatterplot2 extends HybridAdaptor implements ChangeListener
{
	// Versioning for serialisation
	
	static final long serialVersionUID = 50L;
	
	// The parent MDI form
	
	private static Mdi mdiForm;
	
	// The parent drawing surface
	
	private DrawingCanvas drawPane;
	
	// The dimensions of the module
	
	private int height = 228;
	private int width = 253;
	
	// The ScatterPanel object that represents the plot
	
	private ScatterPanel scatterPanel;
	
	// The respective low D positions
	
	ArrayList positions;
	
	// The CSV data
	
	private DataItemCollection dataItems;
	
	// Store the selection objects that are defined in ScatterPanel
	
	private Collection selection;
	private SelectionHandler selectionHandler;

	private JSlider blastSlider;
    private int maxBlast = 250;

    private boolean miObjs=false;

    public Scatterplot2(Mdi mdiForm, DrawingCanvas drawPane)
	{
		super(mdiForm, drawPane);
		
		setName("Scatterplot2");
		setToolTipText("Scatterplot2");
		setLabelCaption(getName());
		
		this.mdiForm = mdiForm;
		this.drawPane = drawPane;
		setPorts();
		setMode(DefaultVisualModule.VISUALISATION_MODE);
		setDimension(width, height);
		setBackground(Color.lightGray);
		addControls();
		
		// *******************************************************************
		// This next line sets the data source as a source anchor so that when it
		// is imported as part of a hybrid algorithm generated by HIVE, it can be
		// identified and swapped by the user's source trigger module
		//
		// This is only a temporary measure here because essentially the anchors
		// will only be identified and set when the hybrid algorithm is configured
		// and added to the 'cookbook' of algorithms that can be generated.
		
		setAnchorType(HybridGenerator.ANCHOR_SINK);
		
		// *******************************************************************
	}
	
	private void addControls()
	{
		scatterPanel = new ScatterPanel(this);

		blastSlider = new JSlider(0, maxBlast);
		blastSlider.setValue(0);
		blastSlider.setEnabled(false);
		blastSlider.addChangeListener(this);
		blastSlider.setBorder(BorderFactory.createTitledBorder("Size of Blast:"));

		((TitledBorder)blastSlider.getBorder()).setTitleColor(Color.gray);
		JPanel slPanel = new JPanel();
		slPanel.add(blastSlider);
	    
		Hashtable labelTable = new Hashtable();

		
		labelTable.put(new Integer(1), new JLabel("0"));
		labelTable.put(new Integer(blastSlider.getMaximum()), new JLabel((new Integer(blastSlider.getMaximum())).toString()));
		
		blastSlider.setMajorTickSpacing(blastSlider.getMaximum() / 4);
		blastSlider.setPaintTicks(true);
		
		blastSlider.setLabelTable(labelTable);
		blastSlider.setPaintLabels(true);
		
		blastSlider.setOpaque(false);
		slPanel.setOpaque(false);

		add(scatterPanel, "Center");
		add(slPanel, "South");

		// Fill out the East and West and south regions of the module's BorderLayout
		// so the table has a border
		
		Filler filler = new Filler(new Dimension(5, 5), new Dimension(5, 5), new Dimension(5, 5));
		//	add(filler, "South");
		filler = new Filler(new Dimension(1, 1), new Dimension(1, 1), new Dimension(2, 2));
		add(filler, "West");
		filler = new Filler(new Dimension(1, 1), new Dimension(1, 1), new Dimension(2, 2));
		add(filler, "East");
		
		// Make the controls visible depending upon the context
		// of the VisualModule
		
		setInterfaceVisibility();	
	}
	
	// Create the ports and append them to the module
	
	private void setPorts()
	{
		int numInPorts = 1;
		int numOutPorts = 2;
		ArrayList ports = new ArrayList(numInPorts + numOutPorts);
		ModulePort port;
		
		// Add 'in' port
		
		port = new ModulePort(this, ScriptModel.INPUT_PORT, 0);
		port.setPortDataStructure(ScriptModel.VECTOR);
		port.setPortLabel("Data in");
		ports.add(port);
		
		// Add 'out' port
		
		port = new ModulePort(this, ScriptModel.SELECTION_PORT, 0);
		port.setPortLabel("Selection");
		ports.add(port);
		
		port = new ModulePort(this, ScriptModel.OUTPUT_PORT, 1);
		port.setPortLabel("Blast");
		ports.add(port);

		addPorts(ports);
	}
	
	/**
	*  This is called when a connected module wants to notify this
	*  module of a change
	*/
	
	public void update(ModulePort fromPort, ModulePort toPort, ArrayList arg){
	    if (arg != null){	
		if (hybridInPlace(fromPort, toPort, arg)) {// Only continue if a hybrid algorithm is in place
		    if (toPort.getKey().equals("i0")){
			// Data has arrived on the input

			//for realign stuff
			if (arg.get(0) instanceof String ){
			    System.out.println("scatterplot - "+(String)arg.get(0));
			    String param = (String)arg.get(0);
			    if (param.equals("Anchors")){
				ArrayList anchors = (ArrayList)arg.get(1);
				scatterPanel.setAnchors(((Integer)anchors.get(0)).intValue(), ((Integer)anchors.get(1)).intValue(), (HashSet)anchors.get(2), (ArrayList)anchors.get(3), (ArrayList)anchors.get(4));
			    }
			    else if (param.equals("NoAnchors"))
				scatterPanel.anchorsAway();
			    else if (param.equals("NextSet"))
				scatterPanel.nextSet();
			    else if (param.equals("buckets")){
				scatterPanel.showBuckets(true, ((ArrayList)arg.get(1)), ((Integer)arg.get(2)).intValue());
			    }
			    else if (param.equals("nobuckets"))
				scatterPanel.showBuckets(false,null,((Integer)arg.get(2)).intValue());
			    else if (param.equals("colours")){
				ArrayList colours = (ArrayList)arg.get(2); ArrayList ar = new ArrayList(); int numBucks = ((Integer)arg.get(1)).intValue();
				for (int z=0; z<numBucks; z++)
				    ar.add(new HashSet((ArrayList)colours.get(z)));
				scatterPanel.setBucket0(numBucks, ar); 
			    }
			    else if (param.equals("nocolours"))
				scatterPanel.resetBucket0();	
			    else if (param.equals("miObjs")){
				miObjs = true;
				System.out.println("miObjs = "+miObjs);
			    }
			
			}
			DataItemCollection tempCSV = dataItems;

			if (arg.get(0) instanceof DataItemCollection){
			    dataItems = (DataItemCollection)arg.get(0);
			
			    if (arg.size() > 1)
				if (arg.get(1) instanceof ArrayList)
				    positions = (ArrayList)arg.get(1);
			    //pivotspring stuff
			    if (arg.size()>2){
				scatterPanel.setPivotIDs(new HashSet((ArrayList)arg.get(2)), (ArrayList)arg.get(2));
			    }
			   
			    // If the CSV data being passed in is the same as the existing
			    // data set, then we need only take notice of the positions data
			    // being passed in.
			    
			    if (tempCSV != (DataItemCollection)arg.get(0)){
				// Only initialise the scatter panel with the data when
				// all of the data (the original set and the low D positions)
				// have been supplied
				
				if ((dataItems != null) && (positions != null)){
				    scatterPanel.init(dataItems, positions);
				    selectionHandler = scatterPanel.getSelectionHandler();
				}
			    }
			    else{
				// Update the existing plotted points
				
				positions = (ArrayList)arg.get(1);
				scatterPanel.setPositions(positions);
				scatterPanel.update();
			    }
			}
			((TitledBorder)blastSlider.getBorder()).setTitleColor(Color.black);	
			blastSlider.setEnabled(true);
		    }

		    else if (toPort.getKey().equals("o0")){
			// Data have arrived on the selection port
			
			if (dataItems != null){
			    selection = (Collection)arg.get(1);
						
			    scatterPanel.setSelection(selection);
			    selectionHandler.updateSelection();
			}
		    }
		}
	    }
	    else{
		// Input module was deleted
		
		miObjs = false;

		dataItems = null;
		positions = null;
		blastSlider.setEnabled(false);
		((TitledBorder)blastSlider.getBorder()).setTitleColor(Color.gray);
		blastSlider.setEnabled(false);
		scatterPanel.init(dataItems, positions);
	    }
	}
    
	/**
	* When the selection is changed, this is called to send the
	* selection to the selction port
	*/
	
	public void sendSelection()
	{	
		// Get references to the selction handling objects
		
		selection = scatterPanel.getSelection();
		
		ArrayList transferData = new ArrayList();
		transferData.add(null);
		transferData.add(selection);
		//transferData.add(new Boolean(miObjs));
		getOutPort(0).sendData(transferData);
	}

    public void dropBomb(Coordinate c){
	ArrayList toSend = new ArrayList();
	toSend.add(c);
	toSend.add(new Double(blastSlider.getValue()));
	getOutPort(1).sendData(toSend);
    }

 
    /**
     * Interface implementation for the threshold slider's
     * ChangeListener
     */
    
    public void stateChanged(ChangeEvent e)
    {
    }
	
}
