/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is HIVE .
 *
 * The Initial Developer of the Original Code is
 * Greg Ross.
 * Portions created by the Initial Developer are Copyright (C) 2000-2004
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s): Greg Ross <gr@dcs.gla.ac.uk>
 		   Matthew Chalmers <matthew@dcs.gla.ac.uk>
 *                 Alistair Morrison <morrisaj@dcs.gla.ac.uk>
 *		   Andrew Didsbury
 *           		
 *	
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/**
 * Algorithmic testbed
 *
 * Scatterplot
 *
 * Class represents an instance of a visual module for a scatterplot visualisation
 *
 *  @author Greg Ross
 */
package alg; 

import parent_gui.dataVolumeThresholding.HybridGenerator;
import parent_gui.dataVolumeThresholding.HybridAdaptor;
import alg.scatterplot.*;
import parent_gui.*;
import data.*;

import java.util.*;
import java.awt.Color;
import java.awt.event.*;
import javax.swing.Box.Filler;
import javax.swing.JLabel;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JButton;
import java.awt.Dimension;

public class Scatterplot extends HybridAdaptor implements ActionListener
{
	// Versioning for serialisation
	
	static final long serialVersionUID = 50L;
	
	// The parent MDI form
	
	private static Mdi mdiForm;
	
	// The parent drawing surface
	
	private DrawingCanvas drawPane;
	
	// The dimensions of the module
	
	private int height = 128;
	private int width = 153;
	
	// The ScatterPanel object that represents the plot
	
	private ScatterPanel scatterPanel;
	
	// The respective low D positions
	
	ArrayList positions;
	
	// The CSV data
	
	private DataItemCollection dataItems;
	
	// Store the selection objects that are defined in ScatterPanel
	
	private Collection selection;
	private SelectionHandler selectionHandler;
	
	// Button to allow the user to reset the zoom and pan settings
	
	private JButton jbReset;
	
	// Button to allow the user to send selected data to the output
	
	private JButton jbSendOutput;
	
	// Label to indicate the number of selected objects
	
	private JLabel jlSelected;
	
	// If the view is to highlight points that represent text docs and are returned
	// by a query, this collection is used to store the keys of those points
	
	private HashSet queryPoints = null;
	
	public Scatterplot(Mdi mdiForm, DrawingCanvas drawPane)
	{
		super(mdiForm, drawPane);
		
		setName("Scatterplot");
		setToolTipText("Scatterplot");
		setLabelCaption(getName());
		
		this.mdiForm = mdiForm;
		this.drawPane = drawPane;
		setPorts();
		setMode(DefaultVisualModule.VISUALISATION_MODE);
		setDimension(width, height);
		setBackground(Color.lightGray);
		addControls();
		
		// *******************************************************************
		// This next line sets the data source as a source anchor so that when it
		// is imported as part of a hybrid algorithm generated by HIVE, it can be
		// identified and swapped by the user's source trigger module
		//
		// This is only a temporary measure here because essentially the anchors
		// will only be identified and set when the hybrid algorithm is configured
		// and added to the 'cookbook' of algorithms that can be generated.
		
		setAnchorType(HybridGenerator.ANCHOR_SINK);
		
		// *******************************************************************
	}
	
	private void addControls()
	{
		// Add the scatterplot panel
		
		scatterPanel = new ScatterPanel(this);
		JPanel cPanel = new JPanel();
		cPanel.setLayout(new BoxLayout(cPanel, BoxLayout.Y_AXIS));
		cPanel.add(scatterPanel);
		
		// Add a JButton to allow the user to reset the zoom and pan settings
		
		jbReset = new JButton("Reset pan/zoom");
		jbReset.setEnabled(false);
		jbReset.setForeground(Color.gray);
		jbReset.addActionListener(this);
		jbReset.setActionCommand("reset");
		
		JPanel bPanel = new JPanel();
		bPanel.setLayout(new BoxLayout(bPanel, BoxLayout.X_AXIS));
		bPanel.add(jbReset);
		cPanel.add(bPanel);
		
		// Add the label to indicate the number of selected items
		
		jlSelected = new JLabel("0 of 0 items selected");
		jlSelected.setForeground(Color.gray);
		Filler filler = new Filler(new Dimension(10, 10), new Dimension(10, 10), new Dimension(10, 10));
		bPanel.add(filler);
		bPanel.add(jlSelected);
		
		// Add a button to allow the user to send selected data to the output
		
		jbSendOutput = new JButton("Output selection");
		jbSendOutput.setForeground(Color.gray);
		jbSendOutput.setEnabled(false);
		jbSendOutput.addActionListener(this);
		jbSendOutput.setActionCommand("send");
		filler = new Filler(new Dimension(10, 10), new Dimension(10, 10), new Dimension(10, 10));
		bPanel.add(filler);
		bPanel.add(jbSendOutput);
		
		add(cPanel, "Center");
		
		// Fill out the East and West and south regions of the module's BorderLayout
		// so the table has a border
		
		filler = new Filler(new Dimension(5, 5), new Dimension(5, 5), new Dimension(5, 5));
		add(filler, "South");
		filler = new Filler(new Dimension(1, 1), new Dimension(1, 1), new Dimension(2, 2));
		add(filler, "West");
		filler = new Filler(new Dimension(1, 1), new Dimension(1, 1), new Dimension(2, 2));
		add(filler, "East");
		
		// Make the controls visible depending upon the context
		// of the VisualModule
		
		setInterfaceVisibility();
	}
	
	/**
	* Implementation of the ActionListener interface
	*/
	
	public void actionPerformed(ActionEvent e)
	{
		if (e.getSource() instanceof JButton)
		{
			JButton button = (JButton)e.getSource();
			if (button.getActionCommand().equals("reset"))
				scatterPanel.reset();
			else if (button.getActionCommand().equals("send"))
			{
				sendSelection();
			}
		}
	}
	
	// Create the ports and append them to the module
	
	private void setPorts()
	{
		int numInPorts = 1;
		int numOutPorts = 2;
		ArrayList ports = new ArrayList(numInPorts + numOutPorts);
		ModulePort port;
		
		// Add 'in' port
		
		port = new ModulePort(this, ScriptModel.INPUT_PORT, 0);
		port.setPortDataStructure(ScriptModel.VECTOR);
		port.setPortLabel("Data in");
		ports.add(port);
		
		// Add 'out' port for selectio
		
		port = new ModulePort(this, ScriptModel.SELECTION_PORT, 0);
		port.setPortLabel("Selection");
		ports.add(port);
		
		// Add an output port for the selected data items. That is, 
		// we might want to send these to another layout algorithm to
		// obtain a sub-layout
		
		port = new ModulePort(this, ScriptModel.OUTPUT_PORT, 1);
		port.setPortLabel("Data out");
		port.setPortDataStructure(ScriptModel.DATA_ITEM_COLLECTION);
		ports.add(port);
		
		addPorts(ports);
	}
	
	/**
	*  This is called when a connected module wants to notify this
	*  module of a change
	*/
	
	public void update(ModulePort fromPort, ModulePort toPort, ArrayList arg)
	{
		if (arg != null)
		{	
			if (hybridInPlace(fromPort, toPort, arg)) // Only continue if a hybrid algorithm is in place
			{
				if (toPort.getKey().equals("i0"))
				{
					// Data has arrived on the input
					
					DataItemCollection tempCSV = dataItems;
					
					if (arg.get(0) instanceof DataItemCollection)
						dataItems = (DataItemCollection)arg.get(0);
					
					if (arg.size() > 1)
						if (arg.get(1) instanceof ArrayList)
							positions = (ArrayList)arg.get(1);
					
					// If the CSV data being passed in is the same as the existing
					// data set, then we need only take notice of the positions data
					// being passed in.
					
					if (arg.get(0) instanceof DataItemCollection)
						if (tempCSV != (DataItemCollection)arg.get(0))
						{
							// Only initialise the scatter panel with the data when
							// all of the data (the original set and the low D positions)
							// have been supplied
							
							if ((dataItems != null) && (positions != null))
							{
								queryPoints = null;
								scatterPanel.init(dataItems, positions);
								selectionHandler = scatterPanel.getSelectionHandler();
							}
						}
						else
						{
							// Update the existing plotted points
							
							positions = (ArrayList)arg.get(1);
							
							scatterPanel.setPositions(positions);
							scatterPanel.update(true);
						}
						
					// enable the reset button
					
					jbReset.setEnabled(true);
					jbReset.setForeground(Color.black);
					
					// Enable the button to allow the user to send the selection to the output
					
					jbSendOutput.setEnabled(true);
					jbSendOutput.setForeground(Color.black);
					
					if (dataItems != null)
					{
						if (selection == null)
							jlSelected.setText(dataItems.getSize() + " of " + dataItems.getSize() + " items selected");
						else
							jlSelected.setText(selection.size() + " of " + dataItems.getSize() + " items selected");
					}
					
					jlSelected.setForeground(Color.black);
				}
				else if (toPort.getKey().equals("o0"))
				{
					// Data has arrived on the selection port
					
					if (dataItems != null)
					{
						queryPoints = null;
						
						// If the collection behind the selection is binary, transposed
						// and from the same data set, and the collection in this scatterplot
						// instance is not transposed, transform the selection so that we highlight
						// items that contain ALL of the selected variables
						// On the other hand, if the above scenario is reversed then apply the opposite
						// transformation
						
						boolean bTransformSelection = false;
						
						if (arg.get(0) instanceof DataItemCollection)
						{
							DataItemCollection selectData = (DataItemCollection)arg.get(0);
							if (selectData != null)
							{
								if (selectData.getDataPath() == dataItems.getDataPath())
								{
									if ((selectData.getTransposed() && selectData.getBinary())
										&& (!dataItems.getTransposed()))
									{
										selection = (Collection)getItemsWithVar((Collection)arg.get(1));
										scatterPanel.setSelection(selection);
										bTransformSelection = true;
									}
									else if ((dataItems.getTransposed() && dataItems.getBinary())
										&& (!selectData.getTransposed()))
									{
										selection = (Collection)getVarsInCommon((Collection)arg.get(1));
										scatterPanel.setSelection(selection);
										bTransformSelection = true;
									}
								}
							}
						}
						
						if (!bTransformSelection)
						{
							selection = (Collection)arg.get(1);
							scatterPanel.setSelection(selection);
						}
						
						selectionHandler.updateSelection();
						
						// If this selection is the result of a query, highlight the points
						// persistently
						
						if (arg.size() > 2)
						{
							if (arg.get(2) instanceof String)
							{
								if (((String)arg.get(2)).equals("queryResults"))
								{
									queryPoints = new HashSet(selection);
								}
							}
						}
					}
				}
			}
		}
		else
		{
			// Input module was deleted
			
			queryPoints = null;
			
			dataItems = null;
			positions = null;
			
			jbReset.setEnabled(false);
			jbReset.setForeground(Color.gray);
			
			// Enable the button to allow the user to send the selection to the output
			
			jbSendOutput.setEnabled(false);
			jbSendOutput.setForeground(Color.gray);
			
			jlSelected.setText("0 of 0 items selected");
			jlSelected.setForeground(Color.gray);
			
			scatterPanel.init(dataItems, positions);
			
			// Send a null to components connected to the data-out port
			
			getOutPort(1).sendData(null);
		}
	}
	
	/**
	* If this plot is a layout of variables (transposed data) and the user
	* has selected some non-transposed items in a connected view, then the
	* highlight only the variables that the selected items have in common
	*/
	
	private HashSet getVarsInCommon(Collection selectIDs)
	{
		HashSet varKeys = new HashSet();
		int itemKey;
		Object[] varValues;
		double varVal = 0;
		ArrayList selIDs = new ArrayList(selectIDs);
		boolean bContainsAll;
		
		for (int j = 0; j < dataItems.getSize(); j++)
		{
			bContainsAll = true;
			varValues = dataItems.getDataItem(j).getValues();
			
			for (int i = 0; i < selIDs.size(); i++)
			{
				itemKey = ((Integer)selIDs.get(i)).intValue();
				
				if (varValues[itemKey] instanceof Double)
				{
					varVal = ((Double)varValues[itemKey]).doubleValue();
				}
				else if (varValues[itemKey] instanceof Integer)
				{
					varVal = ((Integer)varValues[itemKey]).intValue();
				}
				
				if (varVal == 0)
				{
					bContainsAll = false;
				}
			}
			
			if (bContainsAll && selectIDs.size() > 0)
			{
				varKeys.add(new Integer(dataItems.getDataItem(j).getID()));
			}
		}
		return varKeys;
	}
	
	/**
	* If the user selected one or more variables (from a transposed and binary data set)
	* and desires to highlight items (that are not transposed) here, then find the keys
	* of the items that have a non-zero entry for the selected variables
	*/
	
	private HashSet getItemsWithVar(Collection selectIDs)
	{
		HashSet itemKeys = new HashSet();
		int varKey;
		Object[] itemValues;
		double itemVal = 0;
		ArrayList selIDs = new ArrayList(selectIDs);
		boolean bContainsAll;
		
		for (int j = 0; j < dataItems.getSize(); j++)
		{
			bContainsAll = true;
			itemValues = dataItems.getDataItem(j).getValues();
			
			for (int i = 0; i < selIDs.size(); i++)
			{
				varKey = ((Integer)selIDs.get(i)).intValue();
				
				if (itemValues[varKey] instanceof Double)
				{
					itemVal = ((Double)itemValues[varKey]).doubleValue();
				}
				else if (itemValues[varKey] instanceof Integer)
				{
					itemVal = ((Integer)itemValues[varKey]).intValue();
				}
				
				if (itemVal == 0)
				{
					bContainsAll = false;
				}
			}
			
			if (bContainsAll && selectIDs.size() > 0)
			{
				itemKeys.add(new Integer(dataItems.getDataItem(j).getID()));
			}
		}
		return itemKeys;
	}
	
	/**
	* When the selection is changed, this is called to send the
	* selection to the selection port and the output port
	*/
	
	public void sendSelection()
	{
		jlSelected.setText(scatterPanel.getSelectionData().size() + " of " + dataItems.getSize() + " items selected");
		
		ArrayList transferData = new ArrayList(3);
		
		// Create a new DataItemCollection from the selected points and
		// sends it to the output
		
		DataItemCollection selectedData;
		int[] itemIndices = new int[scatterPanel.getSelectionData().size()];
		
		for (int j = 0; j < scatterPanel.getSelectionData().size(); j++)
		{
			itemIndices[j] = ((Integer)scatterPanel.getSelectionData().get(j)).intValue();
		}
		
		selectedData = dataItems.createNewCollection(itemIndices);
		
		transferData.add(selectedData);
		
		// Also add a reference to the original DataItemCollection
		
		transferData.add(dataItems);
		
		// If the rows are labelled, add the labels to the output
		
		if (dataItems.getRowLabels() != null)
		{
			ArrayList rowLabels = selectedData.getRowLabels();
			transferData.add(rowLabels);
		}
		
		getOutPort(1).sendData(transferData);
	}
	
	public void sendSelectPort()
	{
		// Get references to the selection handling objects
		// Send the output to the selection port
		
		ArrayList transferData = new ArrayList(2);
		selection = scatterPanel.getSelection();
		transferData = new ArrayList(2);
		transferData.add(dataItems);
		transferData.add(selection);
		getOutPort(0).sendData(transferData);
	}
	
	/**
	* Accessor method to set the label caption for stating how many items are selected
	*/
	
	public void setSelectionNumberCaption(String sText)
	{
		jlSelected.setText(sText);
	}
	
	/**
	* Accessor method to get the results of a query so that they can be persistently highlighted
	*/
	
	public HashSet getQueryPoints()
	{
		return queryPoints;
	}
	
	/**
	* Accessor method accessing the button that the user presses to send the selected
	* data to the output port
	*/
	
	public JButton getSendButton()
	{
		return jbSendOutput;
	}
	
	/**
	* Overriding the method in DefaultVisualModule, this allows the module to tighten the
	* constraints upon inter-port (module) connections
	*/
	
	public boolean allowPortConnection(ModulePort port)
	{
		// In this case don't allow a data source to linked to this module
		// if it represents a triangular matrix.
		
		if (port.getVisualModule() instanceof DataSource_Triangle)
			return false;
		else
			return true;
	}
}
